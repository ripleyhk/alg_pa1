import os, random, math
from objects import Point, Pair

'''
# Author: Hannah Ripley
# Date: 09/30/2024
# Description: Utility methods for generating test Data Sets
'''

# Calculate the Euclidian distance sqrt((x2-x1)^2+(y2-y1)^2)
#
# The following function is used to determine the distance between two Points
# It is used by the algorithm implementions for both Problems 1.b and 1.d
# Calculating the distance between two Points should conceptually be understood to be
# a single discrete operation of running time O(1)
#
# @param point1 first point, containing an x and y coordinate
# @param point 2 second point, containing an x and y coordinate
# @returns Euclidian distance between point1 and point2
def calculate_distance(point1: Point, point2: Point) -> float:
    delta_x2 = math.pow(point2.x - point1.x, 2)
    delta_y2 = math.pow(point2.y - point1.y, 2)
    distance = math.sqrt(delta_x2 + delta_y2)
    return distance

# Remove file artifact generated by test suite
# @param filename name of file to remove
def clean_artifact(filename: str):
    try:
        os.remove(filename)
    except OSError:
        pass

# Remove file artifacts generated by test suite
# @param files list of files to remove
def clean_artifacts(files: list[str]):
    for filename in files:
        clean_artifact(filename)

# Count the number of lines in a file
# @param filename name of file to count lines in
# @returns count of lines in the file
def count_lines(filename: str) -> int:
    lines = 0
    f = open(filename, "r")
    lines = len(f.readlines())
    f.close()
    return lines

# Generate a random point where floor <= x, y <= ceiling
# @param floor lowest possible point-value
# @param ceiling highest possible point value
# @returns a random point
def generate_random_point(floor=0, ceiling=100) -> Point:
    x = random.randint(floor, ceiling)
    y = random.randint(floor, ceiling)
    point = Point(x, y)
    return point

# Generate a random point, some distance away from another point
# @param distance away from other point
# @param other another point
# @returns a new point, distance away from other
def generate_point_by_distance(distance: float, other: Point) -> Point:
    angle = random.uniform(math.pi/-3, math.pi/3)
    x = other.x + distance * math.cos(angle)
    y = other.y + distance * math.sin(angle)
    return Point(x, y)

# Generate a pair of random points:
def generate_random_pair() -> Pair:
    point1 = generate_random_point()
    point2 = generate_random_point()
    dist = calculate_distance(point1, point2)
    return Pair(point1, point2, dist)

# Generate a list of random (i.e. not algorithmically paired) pairs of length size
# @param size of list to generate
# @returns a list of random pairs of points
def generate_random_pairs_list(size: int) -> list[Pair]:
    pairs = []
    for index in range(size):
        pair = generate_random_pair()
        pairs.append(pair)
    return pairs

# Generate a list of random Points of length size
# @param size of list to generate
# @returns a list of random points
def generate_random_points_list(size: int) -> list[Point]:
    points = []
    for index in range(size):
        point = generate_random_point()
        points.append(point)
    return points

# Remove unwanted symbols from input string
# This is primarily to allow various ordered-pair formatting styles
# @params input string to clean
# @returns a string with all "nonclean" characters removed
def clean_input(input: str) -> str:
    clean = ""
    clean_chars = ['0','1','2','3','4','5','6','7','8','9','.',',','-']
    for c in input:
        if c in clean_chars:
            clean += c
    return clean

# Method for parsing points from a string
# @param input string of points
# @returns a list of points
def parse_points(input: str) -> list[Point]:
    points = []
    input = clean_input(input).split(",")
    for index in range(0, len(input), 2):
        x = float(input[index])
        y = float(input[index+1])
        point = Point(x, y)
        points.append(point)
    return points


#
# Generate data sets of each size for use in performance metrics
# @param sizes list of sizes
# @returns set of datasets of points
#
def generate_datasets(sizes: list[int]) -> list[list[Point]]:
    datasets = []
    for size in sizes:
        dataset = generate_random_points_list(size)
        datasets.append(dataset)
    return datasets

# 
# Generate several random datasets, for use in performance metrics
# @returns set of datasets of points
def get_default_datasets() -> list[list[Point]]:
    sizes = [10, 29, 30, 31, 100, 1000, 5000]
    for index in range(10):
        sizes.append(random.randint(2, 1000))
    datasets = generate_datasets(sizes)
    return datasets

#
# Structure for holding a pair known to be the closest pair
# and its associated list of points
# For use generating expected closest pair values
class ClosePair:
    def __init__ (self, pair: Pair, points: list[Point]):
        self.pair = pair
        self.points = points

# Generate a structure containing points and a closest pair
# with a distance of min_dist if specified, else 10
# @param n number of points to generate
# @param min_dist minimum distance between points
# @returns a closepair object, comprised of a list of points and the closest pair
def generate_points_and_pair(n: int, min_dist=10) -> ClosePair:
    points = []
    root = random.randint(1, n-2)
    next_point = generate_random_point()
    points.append(next_point)
    for index in range(1, root):
        distance = min_dist + random.uniform(1, min_dist)
        next_point = generate_point_by_distance(distance, next_point)
        points.append(next_point)

    point = next_point
    next_point = generate_point_by_distance(min_dist, point)
    points.append(next_point)
    pair = Pair(point, next_point, min_dist)

    for index in range(root+1, n):
        distance = min_dist + random.uniform(1, min_dist)
        next_point = generate_point_by_distance(distance, next_point)
        points.append(next_point)

    # randomize the list of points
    random.shuffle(points)
    return ClosePair(pair, points)